#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#include "../common.h"

hitAttributeNV ProcedurePayload hit;

void main() {
  const vec3 center = vec3(0, 0, 0);
  const float radius = 1;

  const vec3 origin = gl_ObjectRayOriginNV;
  const vec3 direction = gl_ObjectRayDirectionNV;
  const float tMin = gl_RayTminNV;
  const float tMax = gl_RayTmaxNV;

  // https://en.wikipedia.org/wiki/Quadratic_formula

  const vec3 oc = origin - center;
  const float a = dot(direction, direction);
  const float b = dot(oc, direction);
  const float c = dot(oc, oc) - radius * radius;
  const float discriminant = b * b - a * c;

  if(discriminant >= 0) {
    const float t1 = (-b - sqrt(discriminant)) / a;
    const float t2 = (-b + sqrt(discriminant)) / a;

    if((tMin <= t1 && t1 < tMax) || (tMin <= t2 && t2 < tMax)) {
      float hT = (tMin <= t1 && t1 < tMax) ? t1 : t2;
      vec3 hitPos = origin + direction * hT;
      vec3 w = (isZero(hitPos.x) && isZero(hitPos.z)) ? vec3(1, 0, 0) : vec3(0, 1, 0);
      vec3 r = normalize(cross(hitPos, w));
      vec3 u = normalize(cross(r, hitPos));
      float theta = 0.001;
      Vertex v0, v1, v2;
      v0.position = hitPos;
      v0.normal = normalize(v0.position);
      v0.uv = vec2(0, 0);
      v1.position = rotation(r, theta) * hitPos;
      v1.normal = normalize(v1.position);
      v1.uv = vec2(0, 0);
      v2.position = rotation(u, -theta) * hitPos;
      v2.normal = normalize(v2.position);
      v2.uv = vec2(0, 0);
      hit.v0 = v0;
      hit.v1 = v1;
      hit.v2 = v2;
      hit.uv = vec2(0, 0);
      reportIntersectionNV(hT, 0);
    }
  }
}
